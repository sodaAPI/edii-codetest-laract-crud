import {
  loadBasic
} from "./chunk-LACICH6S.js";
import {
  AnimatableColor,
  OptionsColor,
  ValueWithRandom,
  Vector,
  arrayRandomIndex,
  calcPositionOrRandomFromSizeRanged,
  deepExtend,
  executeOnSingleOrMultiple,
  getRandom,
  getRangeValue,
  getSize,
  isArray,
  isInArray,
  isNumber,
  isPointInside,
  itemFromArray,
  itemFromSingleOrMultiple,
  randomInRange,
  rangeColorToHsl,
  safeMatchMedia,
  setRangeValue
} from "./chunk-ARFNBGXE.js";
import "./chunk-LQ2VYIYD.js";

// node_modules/tsparticles-plugin-emitters/esm/Shapes/Circle/CircleShape.js
var CircleShape = class {
  randomPosition(position, size, fill) {
    const generateTheta = (x, y) => {
      const u = getRandom() / 4, theta = Math.atan(y / x * Math.tan(2 * Math.PI * u)), v = getRandom();
      if (v < 0.25) {
        return theta;
      } else if (v < 0.5) {
        return Math.PI - theta;
      } else if (v < 0.75) {
        return Math.PI + theta;
      } else {
        return -theta;
      }
    }, radius = (x, y, theta) => x * y / Math.sqrt((y * Math.cos(theta)) ** 2 + (x * Math.sin(theta)) ** 2), [a, b] = [size.width / 2, size.height / 2], randomTheta = generateTheta(a, b), maxRadius = radius(a, b, randomTheta), randomRadius = fill ? maxRadius * Math.sqrt(getRandom()) : maxRadius;
    return {
      x: position.x + randomRadius * Math.cos(randomTheta),
      y: position.y + randomRadius * Math.sin(randomTheta)
    };
  }
};

// node_modules/tsparticles-plugin-emitters/esm/Options/Classes/EmitterLife.js
var EmitterLife = class {
  constructor() {
    this.wait = false;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.count !== void 0) {
      this.count = data.count;
    }
    if (data.delay !== void 0) {
      this.delay = setRangeValue(data.delay);
    }
    if (data.duration !== void 0) {
      this.duration = setRangeValue(data.duration);
    }
    if (data.wait !== void 0) {
      this.wait = data.wait;
    }
  }
};

// node_modules/tsparticles-plugin-emitters/esm/Options/Classes/EmitterRate.js
var EmitterRate = class {
  constructor() {
    this.quantity = 1;
    this.delay = 0.1;
  }
  load(data) {
    if (data === void 0) {
      return;
    }
    if (data.quantity !== void 0) {
      this.quantity = setRangeValue(data.quantity);
    }
    if (data.delay !== void 0) {
      this.delay = setRangeValue(data.delay);
    }
  }
};

// node_modules/tsparticles-plugin-emitters/esm/Options/Classes/EmitterSize.js
var EmitterSize = class {
  constructor() {
    this.mode = "percent";
    this.height = 0;
    this.width = 0;
  }
  load(data) {
    if (data === void 0) {
      return;
    }
    if (data.mode !== void 0) {
      this.mode = data.mode;
    }
    if (data.height !== void 0) {
      this.height = data.height;
    }
    if (data.width !== void 0) {
      this.width = data.width;
    }
  }
};

// node_modules/tsparticles-plugin-emitters/esm/Options/Classes/Emitter.js
var Emitter = class {
  constructor() {
    this.autoPlay = true;
    this.fill = true;
    this.life = new EmitterLife();
    this.rate = new EmitterRate();
    this.shape = "square";
    this.startCount = 0;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.autoPlay !== void 0) {
      this.autoPlay = data.autoPlay;
    }
    if (data.size !== void 0) {
      if (!this.size) {
        this.size = new EmitterSize();
      }
      this.size.load(data.size);
    }
    if (data.direction !== void 0) {
      this.direction = data.direction;
    }
    this.domId = data.domId;
    if (data.fill !== void 0) {
      this.fill = data.fill;
    }
    this.life.load(data.life);
    this.name = data.name;
    this.particles = executeOnSingleOrMultiple(data.particles, (particles) => {
      return deepExtend({}, particles);
    });
    this.rate.load(data.rate);
    if (data.shape !== void 0) {
      this.shape = data.shape;
    }
    if (data.position !== void 0) {
      this.position = {};
      if (data.position.x !== void 0) {
        this.position.x = setRangeValue(data.position.x);
      }
      if (data.position.y !== void 0) {
        this.position.y = setRangeValue(data.position.y);
      }
    }
    if (data.spawnColor !== void 0) {
      if (this.spawnColor === void 0) {
        this.spawnColor = new AnimatableColor();
      }
      this.spawnColor.load(data.spawnColor);
    }
    if (data.startCount !== void 0) {
      this.startCount = data.startCount;
    }
  }
};

// node_modules/tsparticles-plugin-emitters/esm/EmitterInstance.js
var EmitterInstance = class {
  constructor(engine, emitters, container, options2, position) {
    var _a, _b;
    this.emitters = emitters;
    this.container = container;
    this._calcPosition = () => {
      return calcPositionOrRandomFromSizeRanged({
        size: this.container.canvas.size,
        position: this.options.position
      });
    };
    this._destroy = () => {
      this.emitters.removeEmitter(this);
      this._engine.dispatchEvent("emitterDestroyed", {
        container: this.container,
        data: {
          emitter: this
        }
      });
    };
    this._emit = () => {
      if (this._paused) {
        return;
      }
      const quantity = getRangeValue(this.options.rate.quantity);
      this._emitParticles(quantity);
    };
    this._emitParticles = (quantity) => {
      var _a2, _b2;
      const position2 = this.getPosition(), size = this.getSize(), singleParticlesOptions = itemFromSingleOrMultiple(this._particlesOptions);
      for (let i = 0; i < quantity; i++) {
        const particlesOptions2 = deepExtend({}, singleParticlesOptions);
        if (this.spawnColor) {
          const hslAnimation = (_a2 = this.options.spawnColor) == null ? void 0 : _a2.animation;
          if (hslAnimation) {
            this.spawnColor.h = this._setColorAnimation(hslAnimation.h, this.spawnColor.h, 360);
            this.spawnColor.s = this._setColorAnimation(hslAnimation.s, this.spawnColor.s, 100);
            this.spawnColor.l = this._setColorAnimation(hslAnimation.l, this.spawnColor.l, 100);
          }
          if (!particlesOptions2.color) {
            particlesOptions2.color = {
              value: this.spawnColor
            };
          } else {
            particlesOptions2.color.value = this.spawnColor;
          }
        }
        if (!position2) {
          return;
        }
        const pPosition = ((_b2 = this._shape) == null ? void 0 : _b2.randomPosition(position2, size, this.fill)) ?? position2;
        this.container.particles.addParticle(pPosition, particlesOptions2);
      }
    };
    this._prepareToDie = () => {
      var _a2;
      if (this._paused) {
        return;
      }
      const duration = ((_a2 = this.options.life) == null ? void 0 : _a2.duration) !== void 0 ? getRangeValue(this.options.life.duration) : void 0;
      if (this.container.retina.reduceFactor && (this._lifeCount > 0 || this._immortal) && duration !== void 0 && duration > 0) {
        this._duration = duration * 1e3;
      }
    };
    this._setColorAnimation = (animation, initValue, maxValue) => {
      const container2 = this.container;
      if (!animation.enable) {
        return initValue;
      }
      const colorOffset = randomInRange(animation.offset), delay = getRangeValue(this.options.rate.delay), emitFactor = 1e3 * delay / container2.retina.reduceFactor, colorSpeed = getRangeValue(animation.speed ?? 0);
      return (initValue + colorSpeed * container2.fpsLimit / emitFactor + colorOffset * 3.6) % maxValue;
    };
    this._engine = engine;
    this._currentDuration = 0;
    this._currentEmitDelay = 0;
    this._currentSpawnDelay = 0;
    this._initialPosition = position;
    if (options2 instanceof Emitter) {
      this.options = options2;
    } else {
      this.options = new Emitter();
      this.options.load(options2);
    }
    this._spawnDelay = getRangeValue(this.options.life.delay ?? 0) * 1e3 / this.container.retina.reduceFactor;
    this.position = this._initialPosition ?? this._calcPosition();
    this.name = this.options.name;
    this._shape = (_a = this._engine.emitterShapeManager) == null ? void 0 : _a.getShape(this.options.shape);
    this.fill = this.options.fill;
    this._firstSpawn = !this.options.life.wait;
    this._startParticlesAdded = false;
    let particlesOptions = deepExtend({}, this.options.particles);
    particlesOptions ?? (particlesOptions = {});
    particlesOptions.move ?? (particlesOptions.move = {});
    (_b = particlesOptions.move).direction ?? (_b.direction = this.options.direction);
    if (this.options.spawnColor) {
      this.spawnColor = rangeColorToHsl(this.options.spawnColor);
    }
    this._paused = !this.options.autoPlay;
    this._particlesOptions = particlesOptions;
    this.size = this.options.size ?? (() => {
      const size = new EmitterSize();
      size.load({
        height: 0,
        mode: "percent",
        width: 0
      });
      return size;
    })();
    this._lifeCount = this.options.life.count ?? -1;
    this._immortal = this._lifeCount <= 0;
    this._engine.dispatchEvent("emitterCreated", {
      container,
      data: {
        emitter: this
      }
    });
    this.play();
  }
  externalPause() {
    this._paused = true;
    this.pause();
  }
  externalPlay() {
    this._paused = false;
    this.play();
  }
  getPosition() {
    if (this.options.domId) {
      const container = this.container, element = document.getElementById(this.options.domId);
      if (element) {
        const elRect = element.getBoundingClientRect();
        return {
          x: (elRect.x + elRect.width / 2) * container.retina.pixelRatio,
          y: (elRect.y + elRect.height / 2) * container.retina.pixelRatio
        };
      }
    }
    return this.position;
  }
  getSize() {
    const container = this.container;
    if (this.options.domId) {
      const element = document.getElementById(this.options.domId);
      if (element) {
        const elRect = element.getBoundingClientRect();
        return {
          width: elRect.width * container.retina.pixelRatio,
          height: elRect.height * container.retina.pixelRatio
        };
      }
    }
    return getSize(this.size, container.canvas.size);
  }
  pause() {
    if (this._paused) {
      return;
    }
    delete this._emitDelay;
  }
  play() {
    if (this._paused) {
      return;
    }
    if (!(this.container.retina.reduceFactor && (this._lifeCount > 0 || this._immortal || !this.options.life.count) && (this._firstSpawn || this._currentSpawnDelay >= (this._spawnDelay ?? 0)))) {
      return;
    }
    if (this._emitDelay === void 0) {
      const delay = getRangeValue(this.options.rate.delay);
      this._emitDelay = 1e3 * delay / this.container.retina.reduceFactor;
    }
    if (this._lifeCount > 0 || this._immortal) {
      this._prepareToDie();
    }
  }
  resize() {
    const initialPosition = this._initialPosition;
    this.position = initialPosition && isPointInside(initialPosition, this.container.canvas.size, Vector.origin) ? initialPosition : this._calcPosition();
  }
  update(delta) {
    if (this._paused) {
      return;
    }
    if (this._firstSpawn) {
      this._firstSpawn = false;
      this._currentSpawnDelay = this._spawnDelay ?? 0;
      this._currentEmitDelay = this._emitDelay ?? 0;
    }
    if (!this._startParticlesAdded) {
      this._startParticlesAdded = true;
      this._emitParticles(this.options.startCount);
    }
    if (this._duration !== void 0) {
      this._currentDuration += delta.value;
      if (this._currentDuration >= this._duration) {
        this.pause();
        if (this._spawnDelay !== void 0) {
          delete this._spawnDelay;
        }
        if (!this._immortal) {
          this._lifeCount--;
        }
        if (this._lifeCount > 0 || this._immortal) {
          this.position = this._calcPosition();
          this._spawnDelay = getRangeValue(this.options.life.delay ?? 0) * 1e3 / this.container.retina.reduceFactor;
        } else {
          this._destroy();
        }
        this._currentDuration -= this._duration;
        delete this._duration;
      }
    }
    if (this._spawnDelay !== void 0) {
      this._currentSpawnDelay += delta.value;
      if (this._currentSpawnDelay >= this._spawnDelay) {
        this._engine.dispatchEvent("emitterPlay", {
          container: this.container
        });
        this.play();
        this._currentSpawnDelay -= this._currentSpawnDelay;
        delete this._spawnDelay;
      }
    }
    if (this._emitDelay !== void 0) {
      this._currentEmitDelay += delta.value;
      if (this._currentEmitDelay >= this._emitDelay) {
        this._emit();
        this._currentEmitDelay -= this._emitDelay;
      }
    }
  }
};

// node_modules/tsparticles-plugin-emitters/esm/Emitters.js
var Emitters = class {
  constructor(engine, container) {
    this.container = container;
    this._engine = engine;
    this.array = [];
    this.emitters = [];
    this.interactivityEmitters = {
      random: {
        count: 1,
        enable: false
      },
      value: []
    };
    container.getEmitter = (idxOrName) => idxOrName === void 0 || isNumber(idxOrName) ? this.array[idxOrName || 0] : this.array.find((t) => t.name === idxOrName);
    container.addEmitter = (options2, position) => this.addEmitter(options2, position);
    container.removeEmitter = (idxOrName) => {
      const emitter = container.getEmitter(idxOrName);
      if (emitter) {
        this.removeEmitter(emitter);
      }
    };
    container.playEmitter = (idxOrName) => {
      const emitter = container.getEmitter(idxOrName);
      if (emitter) {
        emitter.externalPlay();
      }
    };
    container.pauseEmitter = (idxOrName) => {
      const emitter = container.getEmitter(idxOrName);
      if (emitter) {
        emitter.externalPause();
      }
    };
  }
  addEmitter(options2, position) {
    const emitterOptions = new Emitter();
    emitterOptions.load(options2);
    const emitter = new EmitterInstance(this._engine, this, this.container, emitterOptions, position);
    this.array.push(emitter);
    return emitter;
  }
  handleClickMode(mode) {
    const emitterOptions = this.emitters, modeEmitters = this.interactivityEmitters;
    if (mode !== "emitter") {
      return;
    }
    let emittersModeOptions;
    if (modeEmitters && isArray(modeEmitters.value)) {
      if (modeEmitters.value.length > 0 && modeEmitters.random.enable) {
        emittersModeOptions = [];
        const usedIndexes = [];
        for (let i = 0; i < modeEmitters.random.count; i++) {
          const idx = arrayRandomIndex(modeEmitters.value);
          if (usedIndexes.includes(idx) && usedIndexes.length < modeEmitters.value.length) {
            i--;
            continue;
          }
          usedIndexes.push(idx);
          emittersModeOptions.push(itemFromArray(modeEmitters.value, idx));
        }
      } else {
        emittersModeOptions = modeEmitters.value;
      }
    } else {
      emittersModeOptions = modeEmitters == null ? void 0 : modeEmitters.value;
    }
    const emittersOptions = emittersModeOptions ?? emitterOptions, ePosition = this.container.interactivity.mouse.clickPosition;
    executeOnSingleOrMultiple(emittersOptions, (emitter) => {
      this.addEmitter(emitter, ePosition);
    });
  }
  async init() {
    this.emitters = this.container.actualOptions.emitters;
    this.interactivityEmitters = this.container.actualOptions.interactivity.modes.emitters;
    if (!this.emitters) {
      return;
    }
    if (isArray(this.emitters)) {
      for (const emitterOptions of this.emitters) {
        this.addEmitter(emitterOptions);
      }
    } else {
      this.addEmitter(this.emitters);
    }
  }
  pause() {
    for (const emitter of this.array) {
      emitter.pause();
    }
  }
  play() {
    for (const emitter of this.array) {
      emitter.play();
    }
  }
  removeEmitter(emitter) {
    const index = this.array.indexOf(emitter);
    if (index >= 0) {
      this.array.splice(index, 1);
    }
  }
  resize() {
    for (const emitter of this.array) {
      emitter.resize();
    }
  }
  stop() {
    this.array = [];
  }
  update(delta) {
    for (const emitter of this.array) {
      emitter.update(delta);
    }
  }
};

// node_modules/tsparticles-plugin-emitters/esm/ShapeManager.js
var shapes = /* @__PURE__ */ new Map();
var ShapeManager = class {
  constructor(engine) {
    this._engine = engine;
  }
  addShape(name, drawer) {
    if (!this.getShape(name)) {
      shapes.set(name, drawer);
    }
  }
  getShape(name) {
    return shapes.get(name);
  }
  getSupportedShapes() {
    return shapes.keys();
  }
};

// node_modules/tsparticles-plugin-emitters/esm/Shapes/Square/SquareShape.js
function randomSquareCoordinate(position, offset) {
  return position + offset * (getRandom() - 0.5);
}
var SquareShape = class {
  randomPosition(position, size, fill) {
    if (fill) {
      return {
        x: randomSquareCoordinate(position.x, size.width),
        y: randomSquareCoordinate(position.y, size.height)
      };
    } else {
      const halfW = size.width / 2, halfH = size.height / 2, side = Math.floor(getRandom() * 4), v = (getRandom() - 0.5) * 2;
      switch (side) {
        case 0:
          return {
            x: position.x + v * halfW,
            y: position.y - halfH
          };
        case 1:
          return {
            x: position.x - halfW,
            y: position.y + v * halfH
          };
        case 2:
          return {
            x: position.x + v * halfW,
            y: position.y + halfH
          };
        case 3:
        default:
          return {
            x: position.x + halfW,
            y: position.y + v * halfH
          };
      }
    }
  }
};

// node_modules/tsparticles-plugin-emitters/esm/index.js
var EmittersPlugin = class {
  constructor(engine) {
    this._engine = engine;
    this.id = "emitters";
  }
  getPlugin(container) {
    return new Emitters(this._engine, container);
  }
  loadOptions(options2, source) {
    var _a, _b;
    if (!this.needsPlugin(options2) && !this.needsPlugin(source)) {
      return;
    }
    if (source == null ? void 0 : source.emitters) {
      options2.emitters = executeOnSingleOrMultiple(source.emitters, (emitter) => {
        const tmp = new Emitter();
        tmp.load(emitter);
        return tmp;
      });
    }
    const interactivityEmitters = (_b = (_a = source == null ? void 0 : source.interactivity) == null ? void 0 : _a.modes) == null ? void 0 : _b.emitters;
    if (interactivityEmitters) {
      if (isArray(interactivityEmitters)) {
        options2.interactivity.modes.emitters = {
          random: {
            count: 1,
            enable: true
          },
          value: interactivityEmitters.map((s) => {
            const tmp = new Emitter();
            tmp.load(s);
            return tmp;
          })
        };
      } else {
        const emitterMode = interactivityEmitters;
        if (emitterMode.value !== void 0) {
          if (isArray(emitterMode.value)) {
            options2.interactivity.modes.emitters = {
              random: {
                count: emitterMode.random.count ?? 1,
                enable: emitterMode.random.enable ?? false
              },
              value: emitterMode.value.map((s) => {
                const tmp = new Emitter();
                tmp.load(s);
                return tmp;
              })
            };
          } else {
            const tmp = new Emitter();
            tmp.load(emitterMode.value);
            options2.interactivity.modes.emitters = {
              random: {
                count: emitterMode.random.count ?? 1,
                enable: emitterMode.random.enable ?? false
              },
              value: tmp
            };
          }
        } else {
          const emitterOptions = options2.interactivity.modes.emitters = {
            random: {
              count: 1,
              enable: false
            },
            value: new Emitter()
          };
          emitterOptions.value.load(interactivityEmitters);
        }
      }
    }
  }
  needsPlugin(options2) {
    var _a, _b, _c;
    if (!options2) {
      return false;
    }
    const emitters = options2.emitters;
    return isArray(emitters) && !!emitters.length || emitters !== void 0 || !!((_c = (_b = (_a = options2.interactivity) == null ? void 0 : _a.events) == null ? void 0 : _b.onClick) == null ? void 0 : _c.mode) && isInArray("emitter", options2.interactivity.events.onClick.mode);
  }
};
async function loadEmittersPlugin(engine, refresh = true) {
  if (!engine.emitterShapeManager) {
    engine.emitterShapeManager = new ShapeManager(engine);
  }
  if (!engine.addEmitterShape) {
    engine.addEmitterShape = (name, shape) => {
      var _a;
      (_a = engine.emitterShapeManager) == null ? void 0 : _a.addShape(name, shape);
    };
  }
  const plugin = new EmittersPlugin(engine);
  await engine.addPlugin(plugin, refresh);
  engine.addEmitterShape("circle", new CircleShape());
  engine.addEmitterShape("square", new SquareShape());
}

// node_modules/tsparticles-updater-life/esm/Options/Classes/LifeDelay.js
var LifeDelay = class extends ValueWithRandom {
  constructor() {
    super();
    this.sync = false;
  }
  load(data) {
    if (!data) {
      return;
    }
    super.load(data);
    if (data.sync !== void 0) {
      this.sync = data.sync;
    }
  }
};

// node_modules/tsparticles-updater-life/esm/Options/Classes/LifeDuration.js
var LifeDuration = class extends ValueWithRandom {
  constructor() {
    super();
    this.random.minimumValue = 1e-4;
    this.sync = false;
  }
  load(data) {
    if (!data) {
      return;
    }
    super.load(data);
    if (data.sync !== void 0) {
      this.sync = data.sync;
    }
  }
};

// node_modules/tsparticles-updater-life/esm/Options/Classes/Life.js
var Life = class {
  constructor() {
    this.count = 0;
    this.delay = new LifeDelay();
    this.duration = new LifeDuration();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.count !== void 0) {
      this.count = data.count;
    }
    this.delay.load(data.delay);
    this.duration.load(data.duration);
  }
};

// node_modules/tsparticles-updater-life/esm/LifeUpdater.js
var LifeUpdater = class {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const container = this.container, particlesOptions = particle.options, lifeOptions = particlesOptions.life;
    if (!lifeOptions) {
      return;
    }
    particle.life = {
      delay: container.retina.reduceFactor ? getRangeValue(lifeOptions.delay.value) * (lifeOptions.delay.sync ? 1 : getRandom()) / container.retina.reduceFactor * 1e3 : 0,
      delayTime: 0,
      duration: container.retina.reduceFactor ? getRangeValue(lifeOptions.duration.value) * (lifeOptions.duration.sync ? 1 : getRandom()) / container.retina.reduceFactor * 1e3 : 0,
      time: 0,
      count: lifeOptions.count
    };
    if (particle.life.duration <= 0) {
      particle.life.duration = -1;
    }
    if (particle.life.count <= 0) {
      particle.life.count = -1;
    }
    if (particle.life) {
      particle.spawning = particle.life.delay > 0;
    }
  }
  isEnabled(particle) {
    return !particle.destroyed;
  }
  loadOptions(options2, ...sources) {
    if (!options2.life) {
      options2.life = new Life();
    }
    for (const source of sources) {
      options2.life.load(source == null ? void 0 : source.life);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle) || !particle.life) {
      return;
    }
    const life = particle.life;
    let justSpawned = false;
    if (particle.spawning) {
      life.delayTime += delta.value;
      if (life.delayTime >= particle.life.delay) {
        justSpawned = true;
        particle.spawning = false;
        life.delayTime = 0;
        life.time = 0;
      } else {
        return;
      }
    }
    if (life.duration === -1) {
      return;
    }
    if (particle.spawning) {
      return;
    }
    if (justSpawned) {
      life.time = 0;
    } else {
      life.time += delta.value;
    }
    if (life.time < life.duration) {
      return;
    }
    life.time = 0;
    if (particle.life.count > 0) {
      particle.life.count--;
    }
    if (particle.life.count === 0) {
      particle.destroy();
      return;
    }
    const canvasSize = this.container.canvas.size, widthRange = setRangeValue(0, canvasSize.width), heightRange = setRangeValue(0, canvasSize.width);
    particle.position.x = randomInRange(widthRange);
    particle.position.y = randomInRange(heightRange);
    particle.spawning = true;
    life.delayTime = 0;
    life.time = 0;
    particle.reset();
    const lifeOptions = particle.options.life;
    if (lifeOptions) {
      life.delay = getRangeValue(lifeOptions.delay.value) * 1e3;
      life.duration = getRangeValue(lifeOptions.duration.value) * 1e3;
    }
  }
};

// node_modules/tsparticles-updater-life/esm/index.js
async function loadLifeUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("life", (container) => new LifeUpdater(container), refresh);
}

// node_modules/tsparticles-plugin-motion/esm/Options/Classes/MotionReduce.js
var MotionReduce = class {
  constructor() {
    this.factor = 4;
    this.value = true;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.factor !== void 0) {
      this.factor = data.factor;
    }
    if (data.value !== void 0) {
      this.value = data.value;
    }
  }
};

// node_modules/tsparticles-plugin-motion/esm/Options/Classes/Motion.js
var Motion = class {
  constructor() {
    this.disable = false;
    this.reduce = new MotionReduce();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.disable !== void 0) {
      this.disable = data.disable;
    }
    this.reduce.load(data.reduce);
  }
};

// node_modules/tsparticles-plugin-motion/esm/MotionInstance.js
var MotionInstance = class {
  constructor(container, engine) {
    this._handleMotionChange = (mediaQuery) => {
      const container2 = this._container, motion = container2.actualOptions.motion;
      if (!motion) {
        return;
      }
      container2.retina.reduceFactor = mediaQuery.matches ? motion.disable ? 0 : motion.reduce.value ? 1 / motion.reduce.factor : 1 : 1;
    };
    this._container = container;
    this._engine = engine;
  }
  async init() {
    const container = this._container, options2 = container.actualOptions.motion;
    if (!(options2 && (options2.disable || options2.reduce.value))) {
      container.retina.reduceFactor = 1;
      return;
    }
    const mediaQuery = safeMatchMedia("(prefers-reduced-motion: reduce)");
    if (!mediaQuery) {
      container.retina.reduceFactor = 1;
      return;
    }
    this._handleMotionChange(mediaQuery);
    const handleChange = async () => {
      this._handleMotionChange(mediaQuery);
      try {
        await container.refresh();
      } catch {
      }
    };
    if (mediaQuery.addEventListener !== void 0) {
      mediaQuery.addEventListener("change", handleChange);
    } else if (mediaQuery.addListener !== void 0) {
      mediaQuery.addListener(handleChange);
    }
  }
};

// node_modules/tsparticles-plugin-motion/esm/index.js
var MotionPlugin = class {
  constructor(engine) {
    this.id = "motion";
    this._engine = engine;
  }
  getPlugin(container) {
    return new MotionInstance(container, this._engine);
  }
  loadOptions(options2, source) {
    if (!this.needsPlugin()) {
      return;
    }
    let motionOptions = options2.motion;
    if (!(motionOptions == null ? void 0 : motionOptions.load)) {
      options2.motion = motionOptions = new Motion();
    }
    motionOptions.load(source == null ? void 0 : source.motion);
  }
  needsPlugin() {
    return true;
  }
};
async function loadMotionPlugin(engine, refresh = true) {
  await engine.addPlugin(new MotionPlugin(engine), refresh);
}

// node_modules/tsparticles-updater-roll/esm/Utils.js
function initParticle(particle) {
  const rollOpt = particle.options.roll;
  if (!(rollOpt == null ? void 0 : rollOpt.enable)) {
    particle.roll = {
      enable: false,
      horizontal: false,
      vertical: false,
      angle: 0,
      speed: 0
    };
    return;
  }
  particle.roll = {
    enable: rollOpt.enable,
    horizontal: rollOpt.mode === "horizontal" || rollOpt.mode === "both",
    vertical: rollOpt.mode === "vertical" || rollOpt.mode === "both",
    angle: getRandom() * Math.PI * 2,
    speed: getRangeValue(rollOpt.speed) / 360
  };
  if (rollOpt.backColor) {
    particle.backColor = rangeColorToHsl(rollOpt.backColor);
  } else if (rollOpt.darken.enable && rollOpt.enlighten.enable) {
    const alterType = getRandom() >= 0.5 ? "darken" : "enlighten";
    particle.roll.alter = {
      type: alterType,
      value: getRangeValue(alterType === "darken" ? rollOpt.darken.value : rollOpt.enlighten.value)
    };
  } else if (rollOpt.darken.enable) {
    particle.roll.alter = {
      type: "darken",
      value: getRangeValue(rollOpt.darken.value)
    };
  } else if (rollOpt.enlighten.enable) {
    particle.roll.alter = {
      type: "enlighten",
      value: getRangeValue(rollOpt.enlighten.value)
    };
  }
}
function updateRoll(particle, delta) {
  const roll = particle.options.roll, data = particle.roll;
  if (!data || !(roll == null ? void 0 : roll.enable)) {
    return;
  }
  const speed = data.speed * delta.factor, max = 2 * Math.PI;
  data.angle += speed;
  if (data.angle > max) {
    data.angle -= max;
  }
}

// node_modules/tsparticles-updater-roll/esm/Options/Classes/RollLight.js
var RollLight = class {
  constructor() {
    this.enable = false;
    this.value = 0;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.value !== void 0) {
      this.value = setRangeValue(data.value);
    }
  }
};

// node_modules/tsparticles-updater-roll/esm/Options/Classes/Roll.js
var Roll = class {
  constructor() {
    this.darken = new RollLight();
    this.enable = false;
    this.enlighten = new RollLight();
    this.mode = "vertical";
    this.speed = 25;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.backColor !== void 0) {
      this.backColor = OptionsColor.create(this.backColor, data.backColor);
    }
    this.darken.load(data.darken);
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    this.enlighten.load(data.enlighten);
    if (data.mode !== void 0) {
      this.mode = data.mode;
    }
    if (data.speed !== void 0) {
      this.speed = setRangeValue(data.speed);
    }
  }
};

// node_modules/tsparticles-updater-roll/esm/RollUpdater.js
var RollUpdater = class {
  getTransformValues(particle) {
    var _a;
    const roll = ((_a = particle.roll) == null ? void 0 : _a.enable) && particle.roll, rollHorizontal = roll && roll.horizontal, rollVertical = roll && roll.vertical;
    return {
      a: rollHorizontal ? Math.cos(roll.angle) : void 0,
      d: rollVertical ? Math.sin(roll.angle) : void 0
    };
  }
  init(particle) {
    initParticle(particle);
  }
  isEnabled(particle) {
    const roll = particle.options.roll;
    return !particle.destroyed && !particle.spawning && !!(roll == null ? void 0 : roll.enable);
  }
  loadOptions(options2, ...sources) {
    if (!options2.roll) {
      options2.roll = new Roll();
    }
    for (const source of sources) {
      options2.roll.load(source == null ? void 0 : source.roll);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateRoll(particle, delta);
  }
};

// node_modules/tsparticles-updater-roll/esm/index.js
async function loadRollUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("roll", () => new RollUpdater(), refresh);
}

// node_modules/tsparticles-updater-rotate/esm/Options/Classes/RotateAnimation.js
var RotateAnimation = class {
  constructor() {
    this.enable = false;
    this.speed = 0;
    this.decay = 0;
    this.sync = false;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      this.speed = setRangeValue(data.speed);
    }
    if (data.decay !== void 0) {
      this.decay = setRangeValue(data.decay);
    }
    if (data.sync !== void 0) {
      this.sync = data.sync;
    }
  }
};

// node_modules/tsparticles-updater-rotate/esm/Options/Classes/Rotate.js
var Rotate = class extends ValueWithRandom {
  constructor() {
    super();
    this.animation = new RotateAnimation();
    this.direction = "clockwise";
    this.path = false;
    this.value = 0;
  }
  load(data) {
    if (!data) {
      return;
    }
    super.load(data);
    if (data.direction !== void 0) {
      this.direction = data.direction;
    }
    this.animation.load(data.animation);
    if (data.path !== void 0) {
      this.path = data.path;
    }
  }
};

// node_modules/tsparticles-updater-rotate/esm/RotateUpdater.js
function updateRotate(particle, delta) {
  const rotate = particle.rotate, rotateOptions = particle.options.rotate;
  if (!rotate || !rotateOptions) {
    return;
  }
  const rotateAnimation = rotateOptions.animation, speed = (rotate.velocity ?? 0) * delta.factor, max = 2 * Math.PI, decay = rotate.decay ?? 1;
  if (!rotateAnimation.enable) {
    return;
  }
  switch (rotate.status) {
    case "increasing":
      rotate.value += speed;
      if (rotate.value > max) {
        rotate.value -= max;
      }
      break;
    case "decreasing":
    default:
      rotate.value -= speed;
      if (rotate.value < 0) {
        rotate.value += max;
      }
      break;
  }
  if (rotate.velocity && decay !== 1) {
    rotate.velocity *= decay;
  }
}
var RotateUpdater = class {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const rotateOptions = particle.options.rotate;
    if (!rotateOptions) {
      return;
    }
    particle.rotate = {
      enable: rotateOptions.animation.enable,
      value: getRangeValue(rotateOptions.value) * Math.PI / 180
    };
    particle.pathRotation = rotateOptions.path;
    let rotateDirection = rotateOptions.direction;
    if (rotateDirection === "random") {
      const index = Math.floor(getRandom() * 2);
      rotateDirection = index > 0 ? "counter-clockwise" : "clockwise";
    }
    switch (rotateDirection) {
      case "counter-clockwise":
      case "counterClockwise":
        particle.rotate.status = "decreasing";
        break;
      case "clockwise":
        particle.rotate.status = "increasing";
        break;
    }
    const rotateAnimation = rotateOptions.animation;
    if (rotateAnimation.enable) {
      particle.rotate.decay = 1 - getRangeValue(rotateAnimation.decay);
      particle.rotate.velocity = getRangeValue(rotateAnimation.speed) / 360 * this.container.retina.reduceFactor;
      if (!rotateAnimation.sync) {
        particle.rotate.velocity *= getRandom();
      }
    }
    particle.rotation = particle.rotate.value;
  }
  isEnabled(particle) {
    const rotate = particle.options.rotate;
    if (!rotate) {
      return false;
    }
    return !particle.destroyed && !particle.spawning && rotate.animation.enable && !rotate.path;
  }
  loadOptions(options2, ...sources) {
    if (!options2.rotate) {
      options2.rotate = new Rotate();
    }
    for (const source of sources) {
      options2.rotate.load(source == null ? void 0 : source.rotate);
    }
  }
  update(particle, delta) {
    var _a;
    if (!this.isEnabled(particle)) {
      return;
    }
    updateRotate(particle, delta);
    particle.rotation = ((_a = particle.rotate) == null ? void 0 : _a.value) ?? 0;
  }
};

// node_modules/tsparticles-updater-rotate/esm/index.js
async function loadRotateUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("rotate", (container) => new RotateUpdater(container), refresh);
}

// node_modules/tsparticles-shape-square/esm/SquareDrawer.js
var fixFactor = Math.sqrt(2);
var SquareDrawer = class {
  draw(context, particle, radius) {
    const fixedRadius = radius / fixFactor, fixedDiameter = fixedRadius * 2;
    context.rect(-fixedRadius, -fixedRadius, fixedDiameter, fixedDiameter);
  }
  getSidesCount() {
    return 4;
  }
};

// node_modules/tsparticles-shape-square/esm/index.js
async function loadSquareShape(engine, refresh = true) {
  await engine.addShape(["edge", "square"], new SquareDrawer(), refresh);
}

// node_modules/tsparticles-updater-tilt/esm/Options/Classes/TiltAnimation.js
var TiltAnimation = class {
  constructor() {
    this.enable = false;
    this.speed = 0;
    this.decay = 0;
    this.sync = false;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      this.speed = setRangeValue(data.speed);
    }
    if (data.decay !== void 0) {
      this.decay = setRangeValue(data.decay);
    }
    if (data.sync !== void 0) {
      this.sync = data.sync;
    }
  }
};

// node_modules/tsparticles-updater-tilt/esm/Options/Classes/Tilt.js
var Tilt = class extends ValueWithRandom {
  constructor() {
    super();
    this.animation = new TiltAnimation();
    this.direction = "clockwise";
    this.enable = false;
    this.value = 0;
  }
  load(data) {
    super.load(data);
    if (!data) {
      return;
    }
    this.animation.load(data.animation);
    if (data.direction !== void 0) {
      this.direction = data.direction;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
  }
};

// node_modules/tsparticles-updater-tilt/esm/Utils.js
function updateTilt(particle, delta) {
  if (!particle.tilt || !particle.options.tilt) {
    return;
  }
  const tilt = particle.options.tilt, tiltAnimation = tilt.animation, speed = (particle.tilt.velocity ?? 0) * delta.factor, max = 2 * Math.PI, decay = particle.tilt.decay ?? 1;
  if (!tiltAnimation.enable) {
    return;
  }
  switch (particle.tilt.status) {
    case "increasing":
      particle.tilt.value += speed;
      if (particle.tilt.value > max) {
        particle.tilt.value -= max;
      }
      break;
    case "decreasing":
    default:
      particle.tilt.value -= speed;
      if (particle.tilt.value < 0) {
        particle.tilt.value += max;
      }
      break;
  }
  if (particle.tilt.velocity && decay !== 1) {
    particle.tilt.velocity *= decay;
  }
}

// node_modules/tsparticles-updater-tilt/esm/TiltUpdater.js
var TiltUpdater = class {
  constructor(container) {
    this.container = container;
  }
  getTransformValues(particle) {
    var _a;
    const tilt = ((_a = particle.tilt) == null ? void 0 : _a.enable) && particle.tilt;
    return {
      b: tilt ? Math.cos(tilt.value) * tilt.cosDirection : void 0,
      c: tilt ? Math.sin(tilt.value) * tilt.sinDirection : void 0
    };
  }
  init(particle) {
    var _a;
    const tiltOptions = particle.options.tilt;
    if (!tiltOptions) {
      return;
    }
    particle.tilt = {
      enable: tiltOptions.enable,
      value: getRangeValue(tiltOptions.value) * Math.PI / 180,
      sinDirection: getRandom() >= 0.5 ? 1 : -1,
      cosDirection: getRandom() >= 0.5 ? 1 : -1
    };
    let tiltDirection = tiltOptions.direction;
    if (tiltDirection === "random") {
      const index = Math.floor(getRandom() * 2);
      tiltDirection = index > 0 ? "counter-clockwise" : "clockwise";
    }
    switch (tiltDirection) {
      case "counter-clockwise":
      case "counterClockwise":
        particle.tilt.status = "decreasing";
        break;
      case "clockwise":
        particle.tilt.status = "increasing";
        break;
    }
    const tiltAnimation = (_a = particle.options.tilt) == null ? void 0 : _a.animation;
    if (tiltAnimation == null ? void 0 : tiltAnimation.enable) {
      particle.tilt.decay = 1 - getRangeValue(tiltAnimation.decay);
      particle.tilt.velocity = getRangeValue(tiltAnimation.speed) / 360 * this.container.retina.reduceFactor;
      if (!tiltAnimation.sync) {
        particle.tilt.velocity *= getRandom();
      }
    }
  }
  isEnabled(particle) {
    var _a;
    const tiltAnimation = (_a = particle.options.tilt) == null ? void 0 : _a.animation;
    return !particle.destroyed && !particle.spawning && !!(tiltAnimation == null ? void 0 : tiltAnimation.enable);
  }
  loadOptions(options2, ...sources) {
    if (!options2.tilt) {
      options2.tilt = new Tilt();
    }
    for (const source of sources) {
      options2.tilt.load(source == null ? void 0 : source.tilt);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateTilt(particle, delta);
  }
};

// node_modules/tsparticles-updater-tilt/esm/index.js
async function loadTiltUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("tilt", (container) => new TiltUpdater(container), refresh);
}

// node_modules/tsparticles-updater-wobble/esm/Options/Classes/WobbleSpeed.js
var WobbleSpeed = class {
  constructor() {
    this.angle = 50;
    this.move = 10;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.angle !== void 0) {
      this.angle = setRangeValue(data.angle);
    }
    if (data.move !== void 0) {
      this.move = setRangeValue(data.move);
    }
  }
};

// node_modules/tsparticles-updater-wobble/esm/Options/Classes/Wobble.js
var Wobble = class {
  constructor() {
    this.distance = 5;
    this.enable = false;
    this.speed = new WobbleSpeed();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.distance !== void 0) {
      this.distance = setRangeValue(data.distance);
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      if (isNumber(data.speed)) {
        this.speed.load({ angle: data.speed });
      } else {
        const rangeSpeed = data.speed;
        if (rangeSpeed.min !== void 0) {
          this.speed.load({ angle: rangeSpeed });
        } else {
          this.speed.load(data.speed);
        }
      }
    }
  }
};

// node_modules/tsparticles-updater-wobble/esm/Utils.js
function updateWobble(particle, delta) {
  const { wobble: wobbleOptions } = particle.options, { wobble } = particle;
  if (!(wobbleOptions == null ? void 0 : wobbleOptions.enable) || !wobble) {
    return;
  }
  const angleSpeed = wobble.angleSpeed * delta.factor, moveSpeed = wobble.moveSpeed * delta.factor, distance = moveSpeed * ((particle.retina.wobbleDistance ?? 0) * delta.factor) / (1e3 / 60), max = 2 * Math.PI, { position } = particle;
  wobble.angle += angleSpeed;
  if (wobble.angle > max) {
    wobble.angle -= max;
  }
  position.x += distance * Math.cos(wobble.angle);
  position.y += distance * Math.abs(Math.sin(wobble.angle));
}

// node_modules/tsparticles-updater-wobble/esm/WobbleUpdater.js
var WobbleUpdater = class {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const wobbleOpt = particle.options.wobble;
    if (wobbleOpt == null ? void 0 : wobbleOpt.enable) {
      particle.wobble = {
        angle: getRandom() * Math.PI * 2,
        angleSpeed: getRangeValue(wobbleOpt.speed.angle) / 360,
        moveSpeed: getRangeValue(wobbleOpt.speed.move) / 10
      };
    } else {
      particle.wobble = {
        angle: 0,
        angleSpeed: 0,
        moveSpeed: 0
      };
    }
    particle.retina.wobbleDistance = getRangeValue((wobbleOpt == null ? void 0 : wobbleOpt.distance) ?? 0) * this.container.retina.pixelRatio;
  }
  isEnabled(particle) {
    var _a;
    return !particle.destroyed && !particle.spawning && !!((_a = particle.options.wobble) == null ? void 0 : _a.enable);
  }
  loadOptions(options2, ...sources) {
    if (!options2.wobble) {
      options2.wobble = new Wobble();
    }
    for (const source of sources) {
      options2.wobble.load(source == null ? void 0 : source.wobble);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateWobble(particle, delta);
  }
};

// node_modules/tsparticles-updater-wobble/esm/index.js
async function loadWobbleUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("wobble", (container) => new WobbleUpdater(container), refresh);
}

// node_modules/tsparticles-preset-confetti/esm/options.js
var options = {
  fullScreen: {
    enable: true,
    zIndex: 100
  },
  fpsLimit: 120,
  particles: {
    number: {
      value: 0
    },
    color: {
      value: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"]
    },
    shape: {
      type: ["square", "circle"]
    },
    opacity: {
      value: { min: 0, max: 1 },
      animation: {
        enable: true,
        speed: 0.5,
        startValue: "max",
        destroy: "min"
      }
    },
    size: {
      value: 5
    },
    links: {
      enable: false
    },
    life: {
      duration: {
        sync: true,
        value: 20 / 6
      },
      count: 1
    },
    move: {
      angle: {
        value: 45,
        offset: 0
      },
      drift: 0,
      enable: true,
      gravity: {
        enable: true,
        acceleration: 9.81
      },
      speed: 45,
      decay: 0.1,
      direction: -90,
      random: true,
      straight: false,
      outModes: {
        default: "none",
        bottom: "destroy"
      }
    },
    rotate: {
      value: {
        min: 0,
        max: 360
      },
      direction: "random",
      animation: {
        enable: true,
        speed: 60
      }
    },
    tilt: {
      direction: "random",
      enable: true,
      value: {
        min: 0,
        max: 360
      },
      animation: {
        enable: true,
        speed: 60
      }
    },
    roll: {
      darken: {
        enable: true,
        value: 25
      },
      enable: true,
      speed: {
        min: 15,
        max: 25
      }
    },
    wobble: {
      distance: 30,
      enable: true,
      speed: {
        min: -15,
        max: 15
      }
    }
  },
  detectRetina: true,
  motion: {
    disable: true
  },
  emitters: {
    name: "confetti",
    startCount: 50,
    position: {
      x: 50,
      y: 50
    },
    size: {
      width: 0,
      height: 0
    },
    rate: {
      delay: 0,
      quantity: 0
    },
    life: {
      duration: 0.1,
      count: 1
    }
  }
};

// node_modules/tsparticles-preset-confetti/esm/index.js
async function loadPreset(engine, refresh = true) {
  await loadBasic(engine, false);
  await loadSquareShape(engine, false);
  await loadEmittersPlugin(engine, false);
  await loadMotionPlugin(engine, false);
  await loadWobbleUpdater(engine, false);
  await loadRollUpdater(engine, false);
  await loadRotateUpdater(engine, false);
  await loadTiltUpdater(engine, false);
  await loadLifeUpdater(engine, false);
  await engine.addPreset("confetti", options, refresh);
}
async function loadConfettiPreset(engine) {
  await loadPreset(engine);
}
export {
  loadConfettiPreset
};
//# sourceMappingURL=tsparticles-preset-confetti.js.map
